## Redux Style Guide

### Introduction

Redux 코드 작성을 위한 공식 스타일 가이드입니다. 여기에는 Redux 애플리케이션 작성을 위한 권장 패턴, 모범 사례 및 제안된 접근 방식이 나열되어 있습니다.

Redux 핵심 라이브러리와 대부분의 Redux 문서는 의견이 없습니다. Redux를 사용하는 방법에는 여러 가지가 있으며 대부분의 경우 작업을 수행하는 단일 "올바른" 방법이 없습니다.

그러나 시간과 경험에 따르면 일부 주제의 경우 특정 접근 방식이 다른 접근 방식보다 더 효과적입니다. 또한 많은 개발자들이 결정 피로도를 줄이기 위해 공식적인 지침을 제공하도록 요청했습니다.

이를 염두에 두고 오류, 자전거 이동 및 패턴 방지를 방지하는 데 도움이 되는 이 권장 사항 목록을 작성했습니다 . 또한 팀 선호도가 다르고 프로젝트마다 요구 사항이 다르기 때문에 모든 크기에 맞는 스타일 가이드가 없다는 것도 이해합니다. 이러한 권장 사항을 따르는 것이 좋지만 시간을 내어 자신의 상황을 평가하고 필요에 맞는지 결정하십시오 .

### Rule 종류

#### 우선순위 A: 필수

이러한 규칙은 오류를 방지하는 데 도움이 되므로 어떤 경우에도 규칙을 배우고 준수합니다 .

#### 우선순위 B: 적극 권장함

이러한 규칙은 대부분의 프로젝트에서 가독성 및/또는 개발자 경험을 향상시키는 것으로 밝혀졌습니다. 코드를 위반해도 코드는 계속 실행되지만 위반은 드물고 정당한 이유가 있어야 합니다.

#### 우선순위 C: 추천함

동등하게 좋은 옵션이 여러 개 있는 경우 일관성을 보장하기 위해 임의의 선택을 할 수 있습니다. 이 규칙에서는 허용되는 각 옵션을 설명하고 기본 선택을 제안합니다 . 즉, 일관성이 있고 합당한 이유가 있는 한 자신의 코드베이스에서 자유롭게 다른 선택을 할 수 있습니다.

### 우선순위 A: 필수

#### 상태를 변경하지 마십시오.

상태를 변경하는 것은 구성 요소가 제대로 다시 렌더링되지 않는 것을 포함하여 Redux 애플리케이션에서 버그의 가장 일반적인 원인이며 Redux DevTools에서 시간 여행 디버깅을 중단시킵니다.

`상태 값의 실제 변형`은 항상 리듀서 내부와 다른 모든 애플리케이션 코드에서 피해야 합니다.

개발 중에 돌연변이를 포착하는 [`redux-immutable-state-invariant`](https://github.com/leoasis/redux-immutable-state-invariant)도구와 같은 도구를 사용하고 상태 업데이트에서 우발적인 돌연변이를 피하려면 [Immer 를 사용하십시오.](https://immerjs.github.io/immer/)

> 참고 : `기존 값`의 복사본 을 수정하는 것은 괜찮습니다. 이는 변경할 수 없는 업데이트 논리를 작성하는 일반적인 부분입니다. 또한 Immer 라이브러리를 변경할 수 없는 업데이트에 사용하는 경우 실제 데이터가 변경되지 않기 때문에 "변경" 로직을 작성하는 것이 허용됩니다. Immer는 변경 사항을 안전하게 추적하고 내부적으로 변경 불가능하게 업데이트된 값을 생성합니다.

#### Reducer는 Side Effect이 없어야 합니다

Reducer 함수는 `state` 및 `action` 인수에만 의존해야 하며 해당 인수를 기반으로 새 상태 값만 계산하고 반환해야 합니다.

어떤 종류의 비동기 로직(AJAX 호출, setTimeOut, promise)도 실행하거나, 임의의 값(Date.now(), Math.random())을 생성하거나, 리듀서 외부에서 변수를 수정하거나, 외부에 영향을 주는 다른 코드를 감속기 기능의 범위에서 실행해서는 안 됩니다.

> 참고 : 동일한 규칙을 따르는 한 리듀서가 라이브러리 또는 유틸리티 함수에서 가져오기와 같이 자체 외부에 정의된 다른 함수를 호출하도록 하는 것은 허용됩니다.

> `Detail`<br/>
> 이 규칙의 목적은 리듀서가 호출될 때 예측 가능하게 동작하도록 보장하는 것입니다. 예를 들어, 시간 여행 디버깅을 수행하는 경우 "현재" 상태 값을 생성하기 위해 이전 작업과 함께 감속기 기능이 여러 번 호출될 수 있습니다.
> <br/> 리듀서에 부작용이 있는 경우 디버깅 프로세스 중에 이러한 효과가 실행되어 응용 프로그램이 예기치 않은 방식으로 작동하게 됩니다.
> <br/>이 규칙에는 회색 영역이 있습니다. 엄밀히 말하면 console.log(state)와 같은 코드는 부작용이지만 실제로는 애플리케이션이 작동하는 방식에 영향을 주지 않습니다.

#### State 또는 Action에 직렬화할 수 없는 값을 두지 마십시오.

Promises, Symbols, Maps/Sets, 함수 또는 클래스 인스턴스와 같은 직렬화할 수 없는 값을 Redux 저장소 상태 또는 디스패치된 작업에 두지 마십시오. 이렇게 하면 Redux DevTools를 통한 디버깅과 같은 기능이 예상대로 작동합니다. 또한 UI가 예상대로 업데이트되도록 합니다.

> `Exception`<br/>
> 액션이 리듀서에 도달하기 전에 미들웨어에 의해 가로채어 중지된다면 직렬화할 수 없는 값을 액션에 넣을 수 있습니다. redux-thunk 및 redux-promise와 같은 미들웨어가 그 예입니다.

#### 앱당 하나의 Redux 스토어

표준 Redux 응용 프로그램에는 전체 응용 프로그램에서 사용할 단일 Redux 저장소 인스턴스만 있어야 합니다. 일반적으로 `store.js`와 같은 별도의 파일에 정의해야 합니다.

이상적으로는 어떤 앱 로직도 스토어를 직접 가져오지 않습니다. `<Provider>`를 통해 React 컴포넌트 트리에 전달하거나 썽크와 같은 미들웨어를 통해 간접적으로 참조해야 합니다. 드문 경우지만 다른 로직 파일로 가져와야 할 수도 있지만 이것은 최후의 수단이어야 합니다.

### 우선순위 B: 적극 권장함

#### Redux 툴킷 사용하여 Redux 로직 작성

Redux Toolkit은 Redux 사용을 위한 권장 도구 세트입니다. 여기에는 돌연변이를 포착하고 Redux DevTools Extension을 활성화하고 Immer를 사용하여 변경할 수 없는 업데이트 논리를 단순화하도록 저장소를 설정하는 등 제안된 모범 사례를 기반으로 하는 기능이 있습니다.

Redux와 함께 RTK를 사용할 필요는 없으며 원하는 경우 다른 접근 방식을 자유롭게 사용할 수 있지만 RTK를 사용하면 논리가 단순화되고 애플리케이션이 올바른 기본값으로 설정됩니다.

#### Immer를 사용하여 변경할 수 없는 업데이트 작성

변경할 수 없는 업데이트 논리를 손으로 작성하는 것은 종종 어렵고 오류가 발생하기 쉽습니다.

Immer를 사용하면 "돌연변이" 논리를 사용하여 더 간단한 변경할 수 없는 업데이트를 작성할 수 있으며 앱의 다른 곳에서 돌연변이를 포착하기 위해 개발 중인 상태를 동결할 수도 있습니다.

`Immer를 사용하여 변경 불가능한 업데이트 로직을 작성하는 것이 좋습니다. 가급적이면 Redux Toolkit의 일부로 사용하는 것이 좋습니다.`

#### 단일 로직 파일들을 Feature 폴더로 파일 구조화

Redux 자체는 애플리케이션의 폴더와 파일이 어떻게 구성되어 있는지 신경 쓰지 않습니다. 그러나 주어진 기능에 대한 논리를 한 곳에 배치하면 일반적으로 해당 코드를 더 쉽게 유지 관리할 수 있습니다.

이 때문에 대부분의 응용 프로그램은 "feature 폴더" 접근 방식을 사용하여 파일을 구조화해야 합니다(같은 폴더에 있는 기능에 대한 모든 파일).

주어진 기능 폴더 내에서 해당 기능에 대한 Redux 로직은 단일 "슬라이스" 파일로 작성되어야 하며 가급적이면 Redux Toolkit createSlice API를 사용하여 작성해야 합니다. (이것을 `"ducks" 패턴`이라고도 합니다).

이전 Redux 코드베이스는 "actions" 및 "reducers"에 대해 별도의 폴더가 있는 "folder-by-type" 접근 방식을 자주 사용했지만 관련 논리를 함께 유지하면 해당 코드를 더 쉽게 찾고 업데이트할 수 있습니다.

> Detail<br>
> 폴더 구조의 예는 다음과 같습니다.<br>
>
> - /src<br>
>   - index.tsx: React 구성 요소 트리를 렌더링하는 진입점 파일<br>
>   - /app<br>
>     - store.ts: store 설정<br>
>     * rootReducer.ts: 루트 리듀서(선택 사항)<br>
>     * App.tsx: 루트 React 구성 요소<br>
>   - /common: 후크, 일반 구성 요소, 유틸리티 등<br>
>   - /features: 모든 "feature 폴더"를 포함합니다.<br>
>     - /todos: 단일 feature 폴더<br>
>       - todosSlice.ts: Redux reducer 로직 및 관련 작업
>       - Todos.tsx: React 컴포넌트

> /app에는 다른 모든 폴더에 의존하는 앱 전체 설정 및 레이아웃이 포함되어 있습니다.<br>
> /common은 진정으로 일반적이고 재사용 가능한 유틸리티와 구성 요소를 포함합니다.<br>
> /features에는 특정 feature과 관련된 모든 feature이 포함된 폴더가 있습니다. 이 예에서 todosSlice.ts는 RTK의 createSlice() 함수에 대한 호출을 포함하고 슬라이스 리듀서 및 액션 생성기를 내보내는 "ducks" 스타일 파일입니다.

#### 리듀서에 가능한 한 많은 로직을 넣습니다.

가능하면 새 상태를 계산하기 위한 로직을 클릭 핸들러와 같이 작업을 준비하고 전달하는 코드가 아닌 적절한 reducer에 넣으십시오. 이를 통해 더 많은 실제 앱 로직을 쉽게 테스트할 수 있고, 시간 여행 디버깅을 보다 효과적으로 사용할 수 있으며, 돌연변이 및 버그로 이어질 수 있는 일반적인 실수를 피할 수 있습니다.

새로운 상태의 일부 또는 전체가 먼저 계산되어야 하지만(예: 고유 ID 생성) 최소한으로 유지되어야 하는 유효한 경우가 있습니다.

> `Detail`<br>
> Redux 코어는 새로운 상태 값이 리듀서에서 계산되는지 또는 액션 생성 로직에서 계산되는지 실제로 신경 쓰지 않습니다. 예를 들어 할 일 앱의 경우 "toggle todo" 작업에 대한 로직은 할 일 배열을 변경할 수 없도록 업데이트해야 합니다. 액션에 todo ID만 포함하고 리듀서에서 새 배열을 계산하는 것은 합법적입니다.
